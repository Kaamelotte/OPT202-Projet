function [alpha, nbSimul] = rl(x, lme, lmi, dir, simul, nbSimul, dphi, phi, options, omega = 1e-4)############################################################################### rl :## Renvoie le alpha optimal trouvé par recherche linéaire#### INPUT  ##        - x : vecteur contenant la valeur courante à optimiser##        - lme : vecteur contenant les mult de Lagrange courants pour les contraintes d'égalité##        - lmi : vecteur contenant les mult de Lagrange courants pour les contraintes d'inégalité##        - dir = (dk,muk) = dir de descente du gradient pour x et lambda##        - simul : specification du simulateur##        - nbSimul: nombre d'appel du simulateur avant la recherche linéaire##        - dphi: dérivée de phi ##        - phi: fonction de recherche linéaire##        - options : structure specifiant les parametres de fonctionnement de l’algorithme## OUTPUT ##        - alpha: alpha optimal trouvé##        - nbSimul: nbre d'appel au simulateur après la recherche linéaire#############################################################################	n = length(x);	me = length(lme);	mi = length(lmi);		i = 0; #nb d'itérations de la RL	alpha = 1;	pente = omega * dot(dphi,dir); #omega.phi'(z_k).p_k		    dk = dir(1:n);#directionn de descente pour x	lm = dir(n+1:length(dir)); # direction de descente pour les lambda		if options.verb == 2 ##=== Impression ===##		fprintf('---------------------------------------------------------------------------------\n');		fprintf("  Recherche linéaire d'Armijo: |d| = %.2e\n",norm(dir,inf));		fprintf('    Simul =%d, phi = %.5e, pente = %.5e\n\n',nbSimul, phi,pente);		fprintf('    %10s %15s %13s\n','alpha','phip-phi','DF(phi)');	end ##============================## 	##=== Boucle sur i ============================================================##	while true		xp = x + alpha*dk; 					lmep = lme + alpha*lm(1:me); #lambda_{k+1} = \lambda_k + \alpha * mu_k)		lmip =  lmi  + alpha*lm(me+1:me +mi);				[~,cep,cip,gp,aep,aip,~,~] = simul(4,xp,lmep, lmip);		nbSimul += 1;				grdlp = gp + [aep ; aip ]' * [lmep ; lmip ];				Fp = [ grdlp ; [cep; cip] ]; # [ grad l ; c ] cf 2.3 TP2        phip = 0.5 * Fp' * Fp; #0.5*||F(z_k + alpha_k.p_k)||^2}		if options.verb == 2 ##=== Impression ===##			fprintf('    %12.4e %14.5e %14.5e\n',alpha,phip-phi,(phip-phi)/alpha);		end ##============================## 				##=== Test d'optimalité sur phi =======================================##		if phip <= phi + alpha*pente # (phip-phi)/alpha <= pente			break; #Sortie de Recherche linéaire		end ##===========================================================##				alpha = alpha/2;		i = i+1;		##=== Test du nombre d'itérations déjà effectuées ==========================##		if(i > 10)			info.status = 3; #PB dans la RL			break; 		end ##==============================================================##	end##=== Fin boucle i ============================================================##	if options.verb == 2 ##=== Impression ===##		fprintf('  |gl| = %.3e, |ce| = %.3e\n',norm(grdlp,inf),norm(cep,inf));	end ##============================## 		returnend